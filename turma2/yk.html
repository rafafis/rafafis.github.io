<!DOCTYPE html>
<html lang="pt-br">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sensor de proximidade</title>
    <link rel="stylesheet" href="../style.css">
	<link rel="stylesheet" href="../prism.css">
	
</head>

<body>
	<script src="../prism.js"></script>
    <header>
        <h1>Sensor de proximidade</h1>
		<br>
        <h1>Rob√≥tica</h1>
    </header>

    <main>
        <section id="links">
            <h2>Links √∫teis</h2>
            <ul>
              <li><a href="https://www.tinkercad.com/" target="_blank">Tinkercad</a></li>
              <li><a href="https://app.arduino.cc/" target="_blank">Arduino</a></li>
            </ul>
		</section>
        <section>
            <h2>Sensor de proximidade</h2>
    		<h4>Roteiro da aula</h4>
        <a class="btn-pdf"
href=""
            target="_blank">
            üìÑ Baixar Roteiro da Aula (PDF)
        </a>

    <h4>C√≥digo b√°sico</h4>
<pre><code class="language-ino" data-prismjs-copy="Copiar!">
#include &lt;HID.h&gt;

#include &lt;TM1637Display.h&gt;

// Defini√ß√µes dos pinos do display
#define CLK 2
#define DIO 3

// Defini√ß√µes dos pinos do sensor ultrass√¥nico HC-SR04
#define TRIG_PIN 4
#define ECHO_PIN 5

// Cria o objeto display
TM1637Display display(CLK, DIO);

void setup() {
  // Inicializa comunica√ß√£o serial para debug (opcional)
  Serial.begin(9600);

  // Configura o brilho do display
  display.setBrightness(0x0f); // Brilho m√°ximo

  // Configura os pinos do sensor ultrass√¥nico
  pinMode(TRIG_PIN, OUTPUT);
  pinMode(ECHO_PIN, INPUT);

  // Teste inicial do display
  display.showNumberDec(8888, true);
  delay(1000);
  display.clear();
}

void loop() {
  // Mede a dist√¢ncia
  float distancia = medirDistancia();

  // Converte para cent√≠metros e limita a 9999 cm
  int distanciaCm = (int)distancia;
  if (distanciaCm > 9999) {
    distanciaCm = 9999;
  }

  // Exibe no display
  display.showNumberDec(distanciaCm, true);

  // Debug no monitor serial (opcional)
  Serial.print("Dist√¢ncia: ");
  Serial.print(distanciaCm);
  Serial.println(" cm");

  // Pequeno delay para estabilizar as leituras
  delay(100);
}

float medirDistancia() {
  // Limpa o pino TRIG
  digitalWrite(TRIG_PIN, LOW);
  delayMicroseconds(2);

  // Envia um pulso de 10 microssegundos
  digitalWrite(TRIG_PIN, HIGH);
  delayMicroseconds(10);
  digitalWrite(TRIG_PIN, LOW);

  // L√™ o tempo de retorno do pulso
  long duracao = pulseIn(ECHO_PIN, HIGH);

  // Calcula a dist√¢ncia em cent√≠metros
  // Velocidade do som = 343 m/s = 0.0343 cm/¬µs
  // Dist√¢ncia = (tempo * velocidade) / 2
  float distancia = (duracao * 0.0343) / 2;

  return distancia;
}
</code></pre>
<h4>C√≥digo intermedi√°rio</h4>
<pre><code class="language-ino" data-prismjs-copy="Copiar!">
#include &lt;TM1637Display.h&gt;

// Defini√ß√µes dos pinos do display
#define CLK 2
#define DIO 3

// Defini√ß√µes dos pinos do sensor ultrass√¥nico HC-SR04
#define TRIG_PIN 4
#define ECHO_PIN 5

// Cria o objeto display
TM1637Display display(CLK, DIO);

void setup() {
  // Inicializa comunica√ß√£o serial para debug (opcional)
  Serial.begin(9600);

  // Configura o brilho do display
  display.setBrightness(0x0f); // Brilho m√°ximo

  // Configura os pinos do sensor ultrass√¥nico
  pinMode(TRIG_PIN, OUTPUT);
  pinMode(ECHO_PIN, INPUT);

  // Teste inicial do display
  display.showNumberDec(8888, true);
  delay(1000);
  display.clear();
}

void loop() {
  // Mede a dist√¢ncia
  float distancia = medirDistancia();

  // Verifica se a leitura √© v√°lida
  if (distancia > 0) {
    // Converte para cent√≠metros e limita a 9999 cm
    int distanciaCm = (int)(distancia + 0.5); // Arredonda para o inteiro mais pr√≥ximo
    if (distanciaCm > 9999) {
      distanciaCm = 9999;
    }

    // Exibe no display
    display.showNumberDec(distanciaCm, true);

    // Debug no monitor serial (opcional)
    Serial.print("Dist√¢ncia: ");
    Serial.print(distancia, 2); // Mostra com 2 casas decimais
    Serial.print(" cm (Display: ");
    Serial.print(distanciaCm);
    Serial.println(" cm)");
  } else {
    // Erro na leitura - exibe tra√ßos
    uint8_t erro[] = {0x40, 0x40, 0x40, 0x40}; // ----
    display.setSegments(erro);
    Serial.println("Erro na leitura!");
  }

  // Delay para estabilizar as leituras
  delay(200);
}

// Vari√°veis para calibra√ß√£o
const float FATOR_CALIBRACAO = 1.0; // Ajuste este valor conforme necess√°rio
const int NUM_LEITURAS = 5; // N√∫mero de leituras para m√©dia

float medirDistancia() {
  float somaLeituras = 0;
  int leiturasValidas = 0;

  // Faz m√∫ltiplas leituras para calcular m√©dia
  for (int i = 0; i < NUM_LEITURAS; i++) {
    // Limpa o pino TRIG
    digitalWrite(TRIG_PIN, LOW);
    delayMicroseconds(2);

    // Envia um pulso de 10 microssegundos
    digitalWrite(TRIG_PIN, HIGH);
    delayMicroseconds(10);
    digitalWrite(TRIG_PIN, LOW);

    // L√™ o tempo de retorno do pulso
    long duracao = pulseIn(ECHO_PIN, HIGH, 30000); // Timeout de 30ms

    // Verifica se a leitura √© v√°lida
    if (duracao > 0) {
      // Calcula a dist√¢ncia em cent√≠metros
      // Velocidade do som ajustada: 343.2 m/s a 20¬∞C
      float distancia = (duracao * 0.03432) / 2;

      // Aplica fator de calibra√ß√£o
      distancia = distancia * FATOR_CALIBRACAO;

      somaLeituras += distancia;
      leiturasValidas++;
    }

    // Pequeno delay entre leituras
    delayMicroseconds(50);
  }

  // Retorna a m√©dia das leituras v√°lidas
  if (leiturasValidas > 0) {
    return somaLeituras / leiturasValidas;
  } else {
    return -1; // Erro na leitura
  }
}
</code></pre>
<h4>C√≥digo avan√ßado</h4>
Nova Funcionalidade do Buzzer:
Conex√£o:

Buzzer ‚Üí pino 6 (+ resistor de 220Œ© se necess√°rio)

Como Funciona:

Ativa√ß√£o por Proximidade: Buzzer s√≥ toca entre 5cm e 100cm
Frequ√™ncia Vari√°vel:

Distante (100cm): 200 Hz (som grave)
Pr√≥ximo (5cm): 2000 Hz (som agudo)


Velocidade dos Beeps:

Distante: Beeps lentos (1 segundo de intervalo)
Pr√≥ximo: Beeps r√°pidos (0.1 segundo de intervalo)

<pre><code class="language-ino" data-prismjs-copy="Copiar!">
#include &lt;HID.h&gt;
#include &lt;TM1637Display.h&gt;

// Defini√ß√µes dos pinos do display
#define CLK 2
#define DIO 3

// Defini√ß√µes dos pinos do sensor ultrass√¥nico HC-SR04
#define TRIG_PIN 4
#define ECHO_PIN 5

// Defini√ß√£o do pino do buzzer
#define BUZZER_PIN 6

// Cria o objeto display
TM1637Display display(CLK, DIO);

void setup() {
  // Inicializa comunica√ß√£o serial para debug (opcional)
  Serial.begin(9600);

  // Configura o brilho do display
  display.setBrightness(0x0f); // Brilho m√°ximo

  // Configura os pinos do sensor ultrass√¥nico
  pinMode(TRIG_PIN, OUTPUT);
  pinMode(ECHO_PIN, INPUT);

  // Configura o pino do buzzer
  pinMode(BUZZER_PIN, OUTPUT);

  // Teste inicial do display e buzzer
  display.showNumberDec(8888, true);
  tone(BUZZER_PIN, 1000, 200); // Beep de teste
  delay(1000);
  display.clear();
}

void loop() {
  // Mede a dist√¢ncia
  float distancia = medirDistancia();

  // Verifica se a leitura √© v√°lida
  if (distancia > 0) {
    // Converte para cent√≠metros e limita a 9999 cm
    int distanciaCm = (int)(distancia + 0.5); // Arredonda para o inteiro mais pr√≥ximo
    if (distanciaCm > 9999) {
      distanciaCm = 9999;
    }

    // Exibe no display
    display.showNumberDec(distanciaCm, true);

    // Controla o buzzer baseado na dist√¢ncia
    controlarBuzzer(distanciaCm);

    // Debug no monitor serial (opcional)
    Serial.print("Dist√¢ncia: ");
    Serial.print(distancia, 2); // Mostra com 2 casas decimais
    Serial.print(" cm (Display: ");
    Serial.print(distanciaCm);
    Serial.println(" cm)");
  } else {
    // Erro na leitura - exibe tra√ßos
    uint8_t erro[] = {0x40, 0x40, 0x40, 0x40}; // ----
    display.setSegments(erro);
    noTone(BUZZER_PIN); // Para o buzzer em caso de erro
    Serial.println("Erro na leitura!");
  }

  // Delay ajustado para permitir funcionamento do buzzer
  delay(50);
}

// Vari√°veis para calibra√ß√£o
const float FATOR_CALIBRACAO = 1.0; // Ajuste este valor conforme necess√°rio
const int NUM_LEITURAS = 5; // N√∫mero de leituras para m√©dia

// Configura√ß√µes do buzzer
const int DISTANCIA_MAX_BUZZER = 100; // Dist√¢ncia m√°xima para ativar buzzer (cm)
const int DISTANCIA_MIN_BUZZER = 5;   // Dist√¢ncia m√≠nima para buzzer (cm)
const int FREQ_MIN = 200;             // Frequ√™ncia m√≠nima (Hz)
const int FREQ_MAX = 2000;            // Frequ√™ncia m√°xima (Hz)
const int DURACAO_BEEP = 50;          // Dura√ß√£o do beep em ms

float medirDistancia() {
  float somaLeituras = 0;
  int leiturasValidas = 0;

  // Faz m√∫ltiplas leituras para calcular m√©dia
  for (int i = 0; i < NUM_LEITURAS; i++) {
    // Limpa o pino TRIG
    digitalWrite(TRIG_PIN, LOW);
    delayMicroseconds(2);

    // Envia um pulso de 10 microssegundos
    digitalWrite(TRIG_PIN, HIGH);
    delayMicroseconds(10);
    digitalWrite(TRIG_PIN, LOW);

    // L√™ o tempo de retorno do pulso
    long duracao = pulseIn(ECHO_PIN, HIGH, 30000); // Timeout de 30ms

    // Verifica se a leitura √© v√°lida
    if (duracao > 0) {
      // Calcula a dist√¢ncia em cent√≠metros
      // Velocidade do som ajustada: 343.2 m/s a 20¬∞C
      float distancia = (duracao * 0.03432) / 2;

      // Aplica fator de calibra√ß√£o
      distancia = distancia * FATOR_CALIBRACAO;

      somaLeituras += distancia;
      leiturasValidas++;
    }

    // Pequeno delay entre leituras
    delayMicroseconds(50);
  }

  // Retorna a m√©dia das leituras v√°lidas
  if (leiturasValidas > 0) {
    return somaLeituras / leiturasValidas;
  } else {
    return -1; // Erro na leitura
  }
}

void controlarBuzzer(int distancia) {
  // Verifica se a dist√¢ncia est√° dentro da faixa do buzzer
  if (distancia >= DISTANCIA_MIN_BUZZER && distancia <= DISTANCIA_MAX_BUZZER) {

    // Calcula a frequ√™ncia baseada na dist√¢ncia (inversamente proporcional)
    // Quanto menor a dist√¢ncia, maior a frequ√™ncia
    int frequencia = map(distancia, DISTANCIA_MIN_BUZZER, DISTANCIA_MAX_BUZZER, FREQ_MAX, FREQ_MIN);

    // Calcula o intervalo entre beeps (inversamente proporcional √† dist√¢ncia)
    // Quanto menor a dist√¢ncia, menor o intervalo (mais r√°pido)
    int intervalo = map(distancia, DISTANCIA_MIN_BUZZER, DISTANCIA_MAX_BUZZER, 100, 1000);

    // Controla o padr√£o de beeps usando millis() para n√£o bloquear o c√≥digo
    static unsigned long ultimoBeep = 0;
    static bool buzzerLigado = false;

    unsigned long agora = millis();

    if (!buzzerLigado && (agora - ultimoBeep >= intervalo)) {
      // Hora de fazer um beep
      tone(BUZZER_PIN, frequencia, DURACAO_BEEP);
      buzzerLigado = true;
      ultimoBeep = agora;
    } else if (buzzerLigado && (agora - ultimoBeep >= DURACAO_BEEP)) {
      // Hora de parar o beep
      noTone(BUZZER_PIN);
      buzzerLigado = false;
    }

  } else {
    // Dist√¢ncia fora da faixa - para o buzzer
    noTone(BUZZER_PIN);
  }
}
</code></pre>
</section>
</main>
    <footer>
        <p>&copy; 2025 - Dr. Rafael Silva</p>
        <p><a href="./main.html">Voltar para a anterior</a></p>
    </footer>
</body>

</html>
