<!DOCTYPE html>
<html lang="pt-br">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sensor de proximidade</title>
    <link rel="stylesheet" href="../style.css">
	<link rel="stylesheet" href="../prism.css">

</head>

<body>
	<script src="../prism.js"></script>
    <header>
        <h1>Sensor de proximidade</h1>
		<br>
        <h1>Rob√≥tica</h1>
    </header>

    <main>
        <section id="links">
            <h2>Links √∫teis</h2>
            <ul>
              <li><a href="https://www.tinkercad.com/" target="_blank">Tinkercad</a></li>
              <li><a href="https://app.arduino.cc/" target="_blank">Arduino</a></li>
            </ul>
		</section>

        <section>
            <h2>Sensor de proximidade</h2>
    		<h4>Roteiro da aula</h4>
        <a class="btn-pdf"
href=""
            target="_blank">
            üìÑ Baixar Roteiro da Aula (PDF)
        </a>

        <h3>üîß Tutorial de Montagem do Arduino</h3>

        <h4>üìã Materiais Necess√°rios</h4>
        <ul>
            <li>1x Arduino Uno (ou compat√≠vel)</li>
            <li>1x Sensor Ultrass√¥nico HC-SR04</li>
            <li>1x Display TM1637 de 4 d√≠gitos</li>
            <li>1x Buzzer ativo (para c√≥digo avan√ßado)</li>
            <li>1x Protoboard</li>
            <li>Jumpers macho-macho</li>
            <li>1x Resistor de 220Œ© (opcional para buzzer)</li>
            <li>Cabo USB para Arduino</li>
        </ul>

        <h4>üîå Passo a Passo da Montagem</h4>

        <h5>1Ô∏è‚É£ Prepara√ß√£o inicial</h5>
        <ul>
            <li>Conecte o Arduino ao computador via cabo USB</li>
            <li>Abra a IDE do Arduino</li>
            <li>Instale a biblioteca <strong>"TM1637"</strong> (Sketch ‚Üí Include Library ‚Üí Manage Libraries)</li>
        </ul>

        <h5>2Ô∏è‚É£ Conex√£o do Display TM1637</h5>
        <ul>
            <li><strong>CLK</strong> ‚Üí Pino digital <strong>2</strong> do Arduino</li>
            <li><strong>DIO</strong> ‚Üí Pino digital <strong>3</strong> do Arduino</li>
            <li><strong>VCC</strong> ‚Üí <strong>5V</strong> do Arduino</li>
            <li><strong>GND</strong> ‚Üí <strong>GND</strong> do Arduino</li>
        </ul>

        <h5>3Ô∏è‚É£ Conex√£o do Sensor Ultrass√¥nico HC-SR04</h5>
        <ul>
            <li><strong>VCC</strong> ‚Üí <strong>5V</strong> do Arduino</li>
            <li><strong>GND</strong> ‚Üí <strong>GND</strong> do Arduino</li>
            <li><strong>Trig</strong> ‚Üí Pino digital <strong>4</strong> do Arduino</li>
            <li><strong>Echo</strong> ‚Üí Pino digital <strong>5</strong> do Arduino</li>
        </ul>

        <h5>4Ô∏è‚É£ Conex√£o do Buzzer (apenas para c√≥digo avan√ßado)</h5>
        <ul>
            <li><strong>Positivo (+)</strong> ‚Üí Pino digital <strong>6</strong> do Arduino</li>
            <li><strong>Negativo (-)</strong> ‚Üí <strong>GND</strong> do Arduino</li>
            <li><em>Opcional:</em> Adicione resistor de 220Œ© entre o pino 6 e o buzzer</li>
        </ul>

        <h4>‚ö†Ô∏è Dicas Importantes</h4>
        <div style="background-color: #fff3cd; border: 1px solid #ffeaa7; padding: 15px; border-radius: 5px; margin: 15px 0;">
            <ul>
                <li><strong>Desligue o Arduino</strong> antes de fazer as conex√µes</li>
                <li>Verifique as polaridades dos componentes</li>
                <li>Use jumpers de cores diferentes para facilitar identifica√ß√£o</li>
                <li>Teste as conex√µes antes de carregar o c√≥digo</li>
                <li>Se o display n√£o funcionar, verifique as conex√µes CLK e DIO</li>
                <li>O sensor funciona melhor com superf√≠cies planas e s√≥lidas</li>
            </ul>
        </div>

        <h4>üöÄ Testando o Projeto</h4>
        <ol>
            <li>Cole um dos c√≥digos abaixo na IDE do Arduino</li>
            <li>Selecione sua placa: <strong>Tools ‚Üí Board ‚Üí Arduino Uno</strong></li>
            <li>Selecione a porta: <strong>Tools ‚Üí Port ‚Üí COMx</strong></li>
            <li>Fa√ßa o upload do c√≥digo: <strong>Ctrl + U</strong></li>
            <li>Abra o Monitor Serial: <strong>Ctrl + Shift + M</strong></li>
            <li>Teste aproximando e afastando objetos do sensor</li>
        </ol>

    <h4>C√≥digo b√°sico</h4>
    <p><em>Este c√≥digo realiza medi√ß√µes simples de dist√¢ncia e exibe no display.</em></p>
<pre><code class="language-ino" data-prismjs-copy="Copiar!">
#include &lt;TM1637Display.h&gt;

// Defini√ß√µes dos pinos do display
#define CLK 2
#define DIO 3

// Defini√ß√µes dos pinos do sensor ultrass√¥nico HC-SR04
#define TRIG_PIN 4
#define ECHO_PIN 5

// Cria o objeto display
TM1637Display display(CLK, DIO);

void setup() {
  // Inicializa comunica√ß√£o serial para debug (opcional)
  Serial.begin(9600);

  // Configura o brilho do display
  display.setBrightness(0x0f); // Brilho m√°ximo

  // Configura os pinos do sensor ultrass√¥nico
  pinMode(TRIG_PIN, OUTPUT);
  pinMode(ECHO_PIN, INPUT);

  // Teste inicial do display
  display.showNumberDec(8888, true);
  delay(1000);
  display.clear();
}

void loop() {
  // Mede a dist√¢ncia
  float distancia = medirDistancia();

  // Converte para cent√≠metros e limita a 9999 cm
  int distanciaCm = (int)distancia;
  if (distanciaCm > 9999) {
    distanciaCm = 9999;
  }

  // Exibe no display
  display.showNumberDec(distanciaCm, true);

  // Debug no monitor serial (opcional)
  Serial.print("Dist√¢ncia: ");
  Serial.print(distanciaCm);
  Serial.println(" cm");

  // Pequeno delay para estabilizar as leituras
  delay(100);
}

float medirDistancia() {
  // Limpa o pino TRIG
  digitalWrite(TRIG_PIN, LOW);
  delayMicroseconds(2);

  // Envia um pulso de 10 microssegundos
  digitalWrite(TRIG_PIN, HIGH);
  delayMicroseconds(10);
  digitalWrite(TRIG_PIN, LOW);

  // L√™ o tempo de retorno do pulso
  long duracao = pulseIn(ECHO_PIN, HIGH);

  // Calcula a dist√¢ncia em cent√≠metros
  // Velocidade do som = 343 m/s = 0.0343 cm/¬µs
  // Dist√¢ncia = (tempo * velocidade) / 2
  float distancia = (duracao * 0.0343) / 2;

  return distancia;
}
</code></pre>

<h4>C√≥digo intermedi√°rio</h4>
<p><em>Vers√£o aprimorada com m√∫ltiplas leituras, calibra√ß√£o e tratamento de erros.</em></p>
<pre><code class="language-ino" data-prismjs-copy="Copiar!">
#include &lt;TM1637Display.h&gt;

// Defini√ß√µes dos pinos do display
#define CLK 2
#define DIO 3

// Defini√ß√µes dos pinos do sensor ultrass√¥nico HC-SR04
#define TRIG_PIN 4
#define ECHO_PIN 5

// Cria o objeto display
TM1637Display display(CLK, DIO);

// Vari√°veis para calibra√ß√£o
const float FATOR_CALIBRACAO = 1.0; // Ajuste este valor conforme necess√°rio
const int NUM_LEITURAS = 5; // N√∫mero de leituras para m√©dia

void setup() {
  // Inicializa comunica√ß√£o serial para debug (opcional)
  Serial.begin(9600);

  // Configura o brilho do display
  display.setBrightness(0x0f); // Brilho m√°ximo

  // Configura os pinos do sensor ultrass√¥nico
  pinMode(TRIG_PIN, OUTPUT);
  pinMode(ECHO_PIN, INPUT);

  // Teste inicial do display
  display.showNumberDec(8888, true);
  delay(1000);
  display.clear();
}

void loop() {
  // Mede a dist√¢ncia
  float distancia = medirDistancia();

  // Verifica se a leitura √© v√°lida
  if (distancia > 0) {
    // Converte para cent√≠metros e limita a 9999 cm
    int distanciaCm = (int)(distancia + 0.5); // Arredonda para o inteiro mais pr√≥ximo
    if (distanciaCm > 9999) {
      distanciaCm = 9999;
    }

    // Exibe no display
    display.showNumberDec(distanciaCm, true);

    // Debug no monitor serial (opcional)
    Serial.print("Dist√¢ncia: ");
    Serial.print(distancia, 2); // Mostra com 2 casas decimais
    Serial.print(" cm (Display: ");
    Serial.print(distanciaCm);
    Serial.println(" cm)");
  } else {
    // Erro na leitura - exibe tra√ßos
    uint8_t erro[] = {0x40, 0x40, 0x40, 0x40}; // ----
    display.setSegments(erro);
    Serial.println("Erro na leitura!");
  }

  // Delay para estabilizar as leituras
  delay(200);
}

float medirDistancia() {
  float somaLeituras = 0;
  int leiturasValidas = 0;

  // Faz m√∫ltiplas leituras para calcular m√©dia
  for (int i = 0; i < NUM_LEITURAS; i++) {
    // Limpa o pino TRIG
    digitalWrite(TRIG_PIN, LOW);
    delayMicroseconds(2);

    // Envia um pulso de 10 microssegundos
    digitalWrite(TRIG_PIN, HIGH);
    delayMicroseconds(10);
    digitalWrite(TRIG_PIN, LOW);

    // L√™ o tempo de retorno do pulso
    long duracao = pulseIn(ECHO_PIN, HIGH, 30000); // Timeout de 30ms

    // Verifica se a leitura √© v√°lida
    if (duracao > 0) {
      // Calcula a dist√¢ncia em cent√≠metros
      // Velocidade do som ajustada: 343.2 m/s a 20¬∞C
      float distancia = (duracao * 0.03432) / 2;

      // Aplica fator de calibra√ß√£o
      distancia = distancia * FATOR_CALIBRACAO;

      somaLeituras += distancia;
      leiturasValidas++;
    }

    // Pequeno delay entre leituras
    delayMicroseconds(50);
  }

  // Retorna a m√©dia das leituras v√°lidas
  if (leiturasValidas > 0) {
    return somaLeituras / leiturasValidas;
  } else {
    return -1; // Erro na leitura
  }
}
</code></pre>

<h4>C√≥digo avan√ßado</h4>
<p><em>Vers√£o completa com buzzer de proximidade - funciona como sensor de estacionamento!</em></p>
<div style="background-color: #d1ecf1; border: 1px solid #bee5eb; padding: 15px; border-radius: 5px; margin: 15px 0;">
    <h5>üì¢ Nova Funcionalidade do Buzzer:</h5>
    <p><strong>Conex√£o:</strong> Buzzer ‚Üí pino 6 (+ resistor de 220Œ© se necess√°rio)</p>

    <p><strong>Como Funciona:</strong></p>
    <ul>
        <li><strong>Ativa√ß√£o por Proximidade:</strong> Buzzer s√≥ toca entre 5cm e 100cm</li>
        <li><strong>Frequ√™ncia Vari√°vel:</strong>
            <ul>
                <li>Distante (100cm): 200 Hz (som grave)</li>
                <li>Pr√≥ximo (5cm): 2000 Hz (som agudo)</li>
            </ul>
        </li>
        <li><strong>Velocidade dos Beeps:</strong>
            <ul>
                <li>Distante: Beeps lentos (1 segundo de intervalo)</li>
                <li>Pr√≥ximo: Beeps r√°pidos (0.1 segundo de intervalo)</li>
            </ul>
        </li>
    </ul>
</div>

<pre><code class="language-ino" data-prismjs-copy="Copiar!">
#include &lt;TM1637Display.h&gt;

// Defini√ß√µes dos pinos do display
#define CLK 2
#define DIO 3

// Defini√ß√µes dos pinos do sensor ultrass√¥nico HC-SR04
#define TRIG_PIN 4
#define ECHO_PIN 5

// Defini√ß√£o do pino do buzzer
#define BUZZER_PIN 6

// Cria o objeto display
TM1637Display display(CLK, DIO);

// Vari√°veis para calibra√ß√£o
const float FATOR_CALIBRACAO = 1.0; // Ajuste este valor conforme necess√°rio
const int NUM_LEITURAS = 5; // N√∫mero de leituras para m√©dia

// Configura√ß√µes do buzzer
const int DISTANCIA_MAX_BUZZER = 100; // Dist√¢ncia m√°xima para ativar buzzer (cm)
const int DISTANCIA_MIN_BUZZER = 5;   // Dist√¢ncia m√≠nima para buzzer (cm)
const int FREQ_MIN = 200;             // Frequ√™ncia m√≠nima (Hz)
const int FREQ_MAX = 2000;            // Frequ√™ncia m√°xima (Hz)
const int DURACAO_BEEP = 50;          // Dura√ß√£o do beep em ms

void setup() {
  // Inicializa comunica√ß√£o serial para debug (opcional)
  Serial.begin(9600);

  // Configura o brilho do display
  display.setBrightness(0x0f); // Brilho m√°ximo

  // Configura os pinos do sensor ultrass√¥nico
  pinMode(TRIG_PIN, OUTPUT);
  pinMode(ECHO_PIN, INPUT);

  // Configura o pino do buzzer
  pinMode(BUZZER_PIN, OUTPUT);

  // Teste inicial do display e buzzer
  display.showNumberDec(8888, true);
  tone(BUZZER_PIN, 1000, 200); // Beep de teste
  delay(1000);
  display.clear();
}

void loop() {
  // Mede a dist√¢ncia
  float distancia = medirDistancia();

  // Verifica se a leitura √© v√°lida
  if (distancia > 0) {
    // Converte para cent√≠metros e limita a 9999 cm
    int distanciaCm = (int)(distancia + 0.5); // Arredonda para o inteiro mais pr√≥ximo
    if (distanciaCm > 9999) {
      distanciaCm = 9999;
    }

    // Exibe no display
    display.showNumberDec(distanciaCm, true);

    // Controla o buzzer baseado na dist√¢ncia
    controlarBuzzer(distanciaCm);

    // Debug no monitor serial (opcional)
    Serial.print("Dist√¢ncia: ");
    Serial.print(distancia, 2); // Mostra com 2 casas decimais
    Serial.print(" cm (Display: ");
    Serial.print(distanciaCm);
    Serial.println(" cm)");
  } else {
    // Erro na leitura - exibe tra√ßos
    uint8_t erro[] = {0x40, 0x40, 0x40, 0x40}; // ----
    display.setSegments(erro);
    noTone(BUZZER_PIN); // Para o buzzer em caso de erro
    Serial.println("Erro na leitura!");
  }

  // Delay ajustado para permitir funcionamento do buzzer
  delay(50);
}

float medirDistancia() {
  float somaLeituras = 0;
  int leiturasValidas = 0;

  // Faz m√∫ltiplas leituras para calcular m√©dia
  for (int i = 0; i < NUM_LEITURAS; i++) {
    // Limpa o pino TRIG
    digitalWrite(TRIG_PIN, LOW);
    delayMicroseconds(2);

    // Envia um pulso de 10 microssegundos
    digitalWrite(TRIG_PIN, HIGH);
    delayMicroseconds(10);
    digitalWrite(TRIG_PIN, LOW);

    // L√™ o tempo de retorno do pulso
    long duracao = pulseIn(ECHO_PIN, HIGH, 30000); // Timeout de 30ms

    // Verifica se a leitura √© v√°lida
    if (duracao > 0) {
      // Calcula a dist√¢ncia em cent√≠metros
      // Velocidade do som ajustada: 343.2 m/s a 20¬∞C
      float distancia = (duracao * 0.03432) / 2;

      // Aplica fator de calibra√ß√£o
      distancia = distancia * FATOR_CALIBRACAO;

      somaLeituras += distancia;
      leiturasValidas++;
    }

    // Pequeno delay entre leituras
    delayMicroseconds(50);
  }

  // Retorna a m√©dia das leituras v√°lidas
  if (leiturasValidas > 0) {
    return somaLeituras / leiturasValidas;
  } else {
    return -1; // Erro na leitura
  }
}

void controlarBuzzer(int distancia) {
  // Verifica se a dist√¢ncia est√° dentro da faixa do buzzer
  if (distancia >= DISTANCIA_MIN_BUZZER && distancia <= DISTANCIA_MAX_BUZZER) {

    // Calcula a frequ√™ncia baseada na dist√¢ncia (inversamente proporcional)
    // Quanto menor a dist√¢ncia, maior a frequ√™ncia
    int frequencia = map(distancia, DISTANCIA_MIN_BUZZER, DISTANCIA_MAX_BUZZER, FREQ_MAX, FREQ_MIN);

    // Calcula o intervalo entre beeps (inversamente proporcional √† dist√¢ncia)
    // Quanto menor a dist√¢ncia, menor o intervalo (mais r√°pido)
    int intervalo = map(distancia, DISTANCIA_MIN_BUZZER, DISTANCIA_MAX_BUZZER, 100, 1000);

    // Controla o padr√£o de beeps usando millis() para n√£o bloquear o c√≥digo
    static unsigned long ultimoBeep = 0;
    static bool buzzerLigado = false;

    unsigned long agora = millis();

    if (!buzzerLigado && (agora - ultimoBeep >= intervalo)) {
      // Hora de fazer um beep
      tone(BUZZER_PIN, frequencia, DURACAO_BEEP);
      buzzerLigado = true;
      ultimoBeep = agora;
    } else if (buzzerLigado && (agora - ultimoBeep >= DURACAO_BEEP)) {
      // Hora de parar o beep
      noTone(BUZZER_PIN);
      buzzerLigado = false;
    }

  } else {
    // Dist√¢ncia fora da faixa - para o buzzer
    noTone(BUZZER_PIN);
  }
}
</code></pre>

        <h4>üéØ Solu√ß√£o de Problemas Comuns</h4>
        <div style="background-color: #f8d7da; border: 1px solid #f5c6cb; padding: 15px; border-radius: 5px; margin: 15px 0;">
            <ul>
                <li><strong>Display mostra "8888":</strong> Verifique conex√µes CLK e DIO</li>
                <li><strong>Valores inconsistentes:</strong> Verifique conex√µes TRIG e ECHO</li>
                <li><strong>Buzzer n√£o toca:</strong> Verifique polaridade e conex√£o no pino 6</li>
                <li><strong>Erro de compila√ß√£o:</strong> Instale a biblioteca TM1637</li>
                <li><strong>Arduino n√£o reconhecido:</strong> Instale drivers CH340 ou FTDI</li>
            </ul>
        </div>

</section>
</main>
    <footer>
        <p>&copy; 2025 - Dr. Rafael Silva</p>
        <p><a href="./main.html">Voltar para a anterior</a></p>
    </footer>
</body>

</html>
